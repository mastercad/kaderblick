{% extends 'base.html.twig' %}

{% block title %}Dashboard{% endblock %}

{% block body %}    
<style>
    /* Verhindert Textauswahl und Scrollen während Drag auf Touch */
    .card-header, .widget-item, .card-header *, .widget-item * {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
        touch-action: manipulation;
    }
    .drag-active {
        background: rgba(0,123,255,0.08);
        transition: background 0.2s;
    }
</style>

<div class="container-fluid">
    {% if ( is_granted('IS_AUTHENTICATED_FULLY') ) %}
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h1>Dashboard</h1>
        {% if ( is_granted('ROLE_SUPERADMIN') ) %}
        <div class="form-group md-4">
            <input type="checkbox" class="form-check-input" id="defaultWidgetCheckbox">
            <label class="form-check-label" for="defaultWidgetCheckbox">Standard-Dashboard</label>
        </div>
        {% endif %}
        <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#addWidgetModal">
            <i class="fas fa-plus"></i> Widget hinzufügen
        </button>
    </div>

    {# Report Auswahl Modal #}
    <div class="modal fade" id="selectReportModal" tabindex="-1" aria-labelledby="selectReportModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="selectReportModalLabel">Report auswählen</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="reportListLoading" class="text-center my-3" style="display:none;">
                        <div class="spinner-border" role="status"><span class="visually-hidden">Laden...</span></div>
                    </div>
                    <div id="reportListContainer">
                        <!-- Dynamisch per JS geladen -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                    <button type="button" class="btn btn-primary" id="addReportWidgetsBtn">Hinzufügen</button>
                </div>
            </div>
        </div>
    </div>

    <div id="widgetContainer">
        <div class="row widget-grid" id="widgetGrid">
            {% for widget in widgets %}
                <div class="col-md-{{ widget.width }} mb-4 widget-item" data-widget-id="{{ widget.id }}" data-widget-position="{{ widget.position }}">
                    <div class="card h-100">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">{{ widget.type | replace({'_': ' '}) | title }}</h5>
                            <div class="btn-group">
                                <button type="button" class="btn btn-sm btn-outline-secondary widget-refresh" title="Aktualisieren">
                                    <i class="fas fa-sync-alt"></i>
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-secondary widget-settings" title="Einstellungen">
                                    <i class="fas fa-cog"></i>
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-danger widget-delete" title="Entfernen">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <div class="card-body widget-content" data-widget-type="{{ widget.type }}">
                            {# Widget-Inhalt wird per JavaScript geladen #}
                            <div class="text-center">
                                <div class="spinner-border" role="status">
                                    <span class="visually-hidden">Laden...</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            {% endfor %}
        </div>
    </div>
{% else %}
    <section class="welcome">
        <h1>Willkommen zur Spiel- & Teamverwaltung</h1>
        <p>
            Diese Plattform unterstützt Jugendmannschaften bei der Organisation von Spielen, der Verwaltung von Spielern und Trainern sowie der Analyse von Ergebnissen.
        </p>
    </section>
    <section class="features">
        <h2>Was bietet die Anwendung?</h2>
        <ul>
            <li>Spiele und Termine planen</li>
            <li>Spieler- und Trainerprofile verwalten</li>
            <li>Ergebnisse und Statistiken auswerten</li>
            <li>Berichte und Analysen für die Trainingsarbeit</li>
        </ul>
    </section>
    <section class="cta">
        <button class="btn text-start justify-content-start" onclick="const modalManager = (window.modalManager || window.ModalManager); modalManager.showModal('auth_modal')">
            <i class="fas fa-sign-in-alt me-1"></i>
            Jetzt einloggen
        </button>
    </section>
{% endif %}
</div>

{% endblock %}

{% block javascripts %}
    {{ parent() }}
    {% if ( is_granted('ROLE_USER') ) %}
    <!-- Dashboard Modal System -->
    <script src="/js/dashboard-modals.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
        const grid = document.getElementById('widgetGrid');
        let sortableInstance = null;
        let longPressTimer = null;
        let svgCircle = null;
        let dragTarget = null;
        const LONG_PRESS_MS = 600;

        function isRealTouchDevice() {
            return (
                ('ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0)
                && window.matchMedia('(pointer: coarse)').matches
            );
        }

        function createProgressCircle(x, y) {
            const size = 56;
            const stroke = 5;
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', size);
            svg.setAttribute('height', size);
            svg.style.position = 'fixed';
            svg.style.left = (x - size/2) + 'px';
            svg.style.top = (y - size/2) + 'px';
            svg.style.zIndex = 9999;
            svg.style.pointerEvents = 'none';
            svg.style.transition = 'opacity 0.2s';
            svg.style.opacity = '1';
            svg.classList.add('widget-longpress-circle');
            const bg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            bg.setAttribute('cx', size/2);
            bg.setAttribute('cy', size/2);
            bg.setAttribute('r', (size-stroke)/2);
            bg.setAttribute('stroke', '#eee');
            bg.setAttribute('stroke-width', stroke);
            bg.setAttribute('fill', 'none');
            svg.appendChild(bg);
            const fg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            fg.setAttribute('cx', size/2);
            fg.setAttribute('cy', size/2);
            fg.setAttribute('r', (size-stroke)/2);
            fg.setAttribute('stroke', '#007bff');
            fg.setAttribute('stroke-width', stroke);
            fg.setAttribute('fill', 'none');
            fg.setAttribute('stroke-dasharray', Math.PI*(size-stroke));
            fg.setAttribute('stroke-dashoffset', Math.PI*(size-stroke));
            fg.style.transition = 'stroke-dashoffset 0.6s linear';
            svg.appendChild(fg);
            document.body.appendChild(svg);
            return {svg, fg};
        }

        function removeProgressCircle() {
            if (svgCircle && svgCircle.svg) {
                svgCircle.svg.style.opacity = '0';
                setTimeout(() => {
                    if (svgCircle && svgCircle.svg && svgCircle.svg.parentNode) svgCircle.svg.parentNode.removeChild(svgCircle.svg);
                    svgCircle = null;
                }, 200);
            }
        }

        function enableDrag(dragElement, originalTouchEvent) {
            if (!sortableInstance) {
                sortableInstance = new Sortable(grid, {
                    animation: 150,
                    handle: '.card-header',
                    draggable: '.widget-item',
                    onStart: function(evt) {
                        // Optisches Feedback für aktives Widget
                        evt.item.classList.add('drag-active');
                    },
                    onEnd: function(evt) {
                        updateWidgetPositions();
                        // Optisches Feedback zurücksetzen
                        evt.item.classList.remove('drag-active');
                        // Nach Drag nur auf Touch wieder entfernen
                        if (isRealTouchDevice()) {
                            disableDrag();
                        }
                        // Nach Drag: Textauswahl und Scrollen wieder erlauben
                        document.body.style.userSelect = '';
                        document.body.style.touchAction = '';
                    },
                });
            }
            // Workaround: Drag sofort starten
            if (dragElement && originalTouchEvent) {
                // Timeout, damit Sortable initialisiert ist
                setTimeout(() => {
                    // Künstliches touchstart-Event auf das Element feuern
                    const touch = originalTouchEvent.touches[0];
                    const simulatedEvent = new TouchEvent('touchstart', {
                        touches: [new Touch({
                            identifier: Date.now(),
                            target: dragElement,
                            clientX: touch.clientX,
                            clientY: touch.clientY,
                            screenX: touch.screenX,
                            screenY: touch.screenY,
                            pageX: touch.pageX,
                            pageY: touch.pageY
                        })],
                        targetTouches: [],
                        changedTouches: [],
                        bubbles: true,
                        cancelable: true
                    });
                    dragElement.dispatchEvent(simulatedEvent);
                }, 0);
            }
        }
        function disableDrag() {
            if (sortableInstance) {
                sortableInstance.destroy();
                sortableInstance = null;
            }
        }

        // Desktop: Drag sofort, Touch: erst nach Long-Press
        if (!isRealTouchDevice()) {
            enableDrag();
        } else {
            disableDrag();
            let touchMove = false;
            grid.addEventListener('touchstart', function(e) {
                const cardHeader = e.target.closest('.card-header');
                if (!cardHeader) return;
                dragTarget = cardHeader;
                let startX = e.touches[0].clientX;
                let startY = e.touches[0].clientY;
                document.body.style.userSelect = 'none';
                document.body.style.touchAction = 'none';
                e.preventDefault();
                const touch = e.touches[0];
                let feedbackGiven = false;
                let dragAborted = false;
                svgCircle = null;
                longPressTimer = setTimeout(() => {
                    if (dragAborted || !dragTarget) return;
                    if (svgCircle && svgCircle.svg) removeProgressCircle();
                    svgCircle = createProgressCircle(touch.clientX, touch.clientY);
                    setTimeout(() => {
                        if (dragAborted || !dragTarget) return;
                        svgCircle.fg.setAttribute('stroke-dashoffset', 0);
                        setTimeout(() => {
                            if (dragAborted || !dragTarget) return;
                            if (!feedbackGiven) {
                                if (window.navigator.vibrate) window.navigator.vibrate(30);
                                feedbackGiven = true;
                            }
                            removeProgressCircle();
                            enableDrag(cardHeader, e);
                        }, LONG_PRESS_MS);
                    }, 10);
                }, 10);
                function moveHandler(ev) {
                    if (!dragTarget) return;
                    const dx = Math.abs(ev.touches[0].clientX - startX);
                    const dy = Math.abs(ev.touches[0].clientY - startY);
                    if (dx > 10 || dy > 10) {
                        dragAborted = true;
                        clearTimeout(longPressTimer);
                        removeProgressCircle();
                        dragTarget = null;
                        document.body.style.userSelect = '';
                        document.body.style.touchAction = '';
                        grid.removeEventListener('touchmove', moveHandler);
                        grid.removeEventListener('touchend', endHandler);
                    }
                }
                function endHandler() {
                    clearTimeout(longPressTimer);
                    if (!dragAborted) removeProgressCircle();
                    dragTarget = null;
                    document.body.style.userSelect = '';
                    document.body.style.touchAction = '';
                    grid.removeEventListener('touchmove', moveHandler);
                    grid.removeEventListener('touchend', endHandler);
                }
                grid.addEventListener('touchmove', moveHandler, {passive: true});
                grid.addEventListener('touchend', endHandler);
            }, {passive: false});

            grid.addEventListener('touchmove', function(e) {
                if (!dragTarget) return;
                touchMove = true;
                clearTimeout(longPressTimer);
                removeProgressCircle();
                dragTarget = null;
                // Textauswahl und Scrollen wieder erlauben
                document.body.style.userSelect = '';
                document.body.style.touchAction = '';
            }, {passive: true});

            grid.addEventListener('touchend', function(e) {
                clearTimeout(longPressTimer);
                setTimeout(() => {
                    // disableDrag(); // handled in onEnd
                }, 300);
                removeProgressCircle();
                dragTarget = null;
                // Textauswahl und Scrollen wieder erlauben
                document.body.style.userSelect = '';
                document.body.style.touchAction = '';
            });
        }

        document.querySelectorAll('.widget-item').forEach(async widget => {
            await loadWidgetContent(widget);
        });

        function handleWidgetInteraction(e) {
            const deleteBtn = e.target.closest('.widget-delete');
            if (deleteBtn) {
                handleDelete(deleteBtn);
                e.preventDefault();
                return;
            }

            const settingsBtn = e.target.closest('.widget-settings');
            if (settingsBtn) {
                handleSettings(settingsBtn);
                e.preventDefault();
                return;
            }

            const refreshButton = e.target.closest('.widget-refresh');
            if (refreshButton) {
                handleRefresh(refreshButton);
                e.preventDefault();
                return;
            }
        }

        document.addEventListener('pointerup', handleWidgetInteraction);

        const defaultWidgetCheckbox = document.getElementById('defaultWidgetCheckbox');
        if (defaultWidgetCheckbox) {
            defaultWidgetCheckbox.checked = {{ isDefault ? 'true' : 'false' }};
            defaultWidgetCheckbox.addEventListener('change', function() {
                updateWidgetPositions();
            });
        }
    });

        async function handleDelete(button) {
            if (!confirm('Widget wirklich entfernen?')) return;
            
            const widget = button.closest('.widget-item');
            const widgetId = widget.dataset.widgetId;

            try {
                const response = await fetch(`/widget/${widgetId}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    widget.remove();
                }
            } catch (error) {
                console.error('Error:', error);
            }
        }

        function handleSettings(button) {
            const widget = button.closest('.widget-item');
            const widgetId = widget.dataset.widgetId;
            const widgetPosition = widget.dataset.widgetPosition;
            const width = parseInt(widget.className.match(/col-md-(\d+)/)[1]);
            
            const modal = `
                <div class="modal fade" id="widgetSettings${widgetId}" tabindex="-1">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">Widget-Einstellungen</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                            </div>
                            <div class="modal-body">
                                <div class="mb-3">
                                    <label class="form-label">Breite</label>
                                    <select class="selectpicker form-select widget-width">
                                        <option value="3" ${width === 3 ? 'selected' : ''}>Schmal (25%)</option>
                                        <option value="4" ${width === 4 ? 'selected' : ''}>Normal (33%)</option>
                                        <option value="6" ${width === 6 ? 'selected' : ''}>Breit (50%)</option>
                                        <option value="12" ${width === 12 ? 'selected' : ''}>Volle Breite (100%)</option>
                                    </select>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                                <button type="button" class="btn btn-primary save-settings">Speichern</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modal);
            const modalElement = document.getElementById(`widgetSettings${widgetId}`);
            const bsModal = new bootstrap.Modal(modalElement);

            modalElement.querySelector('.save-settings').addEventListener('click', async function() {
                const newWidth = modalElement.querySelector('.widget-width').value;
                widget.className = widget.className.replace(/col-md-\d+/, `col-md-${newWidth}`);
                
                await loadWidgetContent(widget);
//                await saveWidgetSettings(widgetId, { id: widgetId, width: newWidth, position: widgetPosition });
                await updateWidgetPositions();
                bsModal.hide();
                modalElement.remove();
            });
    
            bsModal.show();
        }

        function handleRefresh(button) {
            const widget = button.closest('.widget-item');
            loadWidgetContent(widget);
        }
    </script>
    {% endif %}
{% endblock %}
